/**
 *
 */
class GPUKR : public GPUBase {
public:
  virtual std::string name() { return "GPUKR"; }
  virtual void execute();
};





void GPUKR::execute() {
  cl_int err;

  // preprocessing, init values and simple scan
  cl::Kernel init(*program, "gpu_kr_init_phase", &err);
  CHECKERR;
  // preproccesing part 2, scan phase
  cl::Kernel scan(*program, "gpu_kr_scan_phase", &err);
  CHECKERR;
  // this one will itterate until wanted result is reached
  cl::Kernel propagate(*program, "gpu_label_mask_two", &err);
  CHECKERR;
  cl::Kernel link(*program, "gpu_kr_link_phase", &err);
  CHECKERR;
  cl::Kernel final_phases(*program, "gpu_kr_final_phases", &err);
  CHECKERR;

  err = init.setArg(0, *buf);
  CHECKERR;
  err = init.setArg(1, (cl_int)width);
  CHECKERR;
  err = init.setArg(2, (cl_int)height);
  CHECKERR;

  char iterate = 1;

  LABELTYPE *repLabels = new LABELTYPE[width * height];
  auto size = width * height * sizeof(LABELTYPE);
  cl::Buffer iter(*context, CL_MEM_READ_WRITE, 1, nullptr, &err);
  CHECKERR;
  cl::Buffer repLabelBuf(*context, CL_MEM_READ_WRITE, size, nullptr, &err);
  CHECKERR;

  err = queue->enqueueWriteBuffer(iter, CL_FALSE, 0, 1, &iterate);
  CHECKERR
  err = queue->enqueueWriteBuffer(repLabelBuf, CL_TRUE, 0, size, repLabels);
  CHECKERR;

  err = scan.setArg(0, *buf);
  CHECKERR;
  err = scan.setArg(1, (cl_int)width);
  CHECKERR;
  err = scan.setArg(2, (cl_int)height);
  CHECKERR;
  err = scan.setArg(3, repLabelBuf);
  CHECKERR;

  err = propagate.setArg(0, *buf);
  CHECKERR;
  err = propagate.setArg(1, (cl_int)width);
  CHECKERR;
  err = propagate.setArg(2, (cl_int)height);
  CHECKERR;
  err = propagate.setArg(3, repLabelBuf);
  CHECKERR;

  err = link.setArg(0, *buf);
  CHECKERR;
  err = link.setArg(1, (cl_int)width);
  CHECKERR;
  err = link.setArg(2, (cl_int)height);
  CHECKERR;
  err = link.setArg(3, repLabelBuf);
  CHECKERR;

  err = final_phases.setArg(0, *buf);
  CHECKERR;
  err = final_phases.setArg(1, (cl_int)width);
  CHECKERR;
  err = final_phases.setArg(2, (cl_int)height);
  CHECKERR;
  err = final_phases.setArg(3, iter);
  CHECKERR;
  err = final_phases.setArg(4, repLabelBuf);
  CHECKERR;

  std::vector<cl::Event> events(1);
  std::vector<cl::Event> writtenevents(1);

  err = queue->enqueueNDRangeKernel(init, cl::NullRange,
                                    cl::NDRange(width, height),
                                    cl::NDRange(1, 1), NULL, &events[0]);
  CHECKERR;

  err = queue->enqueueNDRangeKernel(scan, cl::NullRange,
                                    cl::NDRange(width, height),
                                    cl::NDRange(1, 1), NULL, &events[0]);
  CHECKERR;

  int i = 0;

  // since the kernel does't work yet just itterate a few times to compare
  // results
  while (i < 5) {
    i++;
    queue->enqueueReadBuffer(iter, CL_TRUE, 0, 1, &iterate, &events, NULL);
    if (iterate == false) {
      break;
    }
    iterate = false;
    queue->enqueueWriteBuffer(iter, CL_FALSE, 0, 1, &iterate, NULL,
                              &writtenevents[0]);
    queue->enqueueNDRangeKernel(propagate, cl::NullRange,
                                cl::NDRange(width, height), cl::NDRange(1, 1),
                                &writtenevents, &events[0]);

    queue->enqueueNDRangeKernel(link, cl::NullRange, cl::NDRange(width, height),
                                cl::NDRange(1, 1), &writtenevents, &events[0]);

    queue->enqueueNDRangeKernel(final_phases, cl::NullRange,
                                cl::NDRange(width, height), cl::NDRange(1, 1),
                                &writtenevents, &events[0]);
  
  }

  delete[] repLabels;
}







/**
   * Korean CCL algorithm for the gpu
   * originally implemented using CUDA
   */
kernel void gpu_kr_init_phase(global int *d, int w, int h) {
  unsigned int x = get_global_id(0);
  unsigned int y = get_global_id(1);

  int loc = (y * w) + x;

  // Init phase
  if (d[loc] == 1) {
    d[loc] = (loc + 2);
  } else {
    d[loc] = 0;
  }
}

kernel void gpu_kr_scan_phase(global int *d, int w, int h, global int *rLD) {
  // Scan phase
  // check if the init label-value can be improved (=lowered)

  int x = get_global_id(0);
  int y = get_global_id(1);

  int loc = (y * w) + x;

  // west and north pixel position
  int checkW = (y * w) + (x - 1);
  if (x - 1 < 0) {
    checkW = -1;
  }
  int checkN = ((y - 1) * w) + x;
  if (y - 1 < 0) {
    checkN = -1;
  }

  int scanTmp = d[loc];

  if (scanTmp != 0) {
    if (checkN != -1 && checkN >= 0 && checkN < w * h && d[checkN] > 0 && d[checkN] < scanTmp) {
      scanTmp = d[checkN];
    }
    if (checkW != -1 && checkW >= 0 && checkW < w * h && d[checkW] > 0 && d[checkW] < scanTmp) {
      scanTmp = d[checkW];
    }
  }
  if (scanTmp != d[loc]) { 
    rLD[loc] = scanTmp;
  } else {
    rLD[loc] = -2;
  }

}

// datarace a likely problem, lots of index checks included

kernel void gpu_label_mask_two(global int *d, int w, int h, global int *rLD) {
  int x = get_global_id(0);
  int y = get_global_id(1);

  int loc = (y * w) + x;

  if (rLD[loc] != -2 && d[loc] > 0) {
    //atomic_xchg(&d[loc], rLD[loc]);
    d[loc] = rLD[loc];
  }

  int lN = ((y - 1) * w) + x;
  if (y - 1 < 0) {lN = -1;}
  int lE = (y * w) + (x + 1);
  if (x + 1 >= w) {lE = -1;}
  int lS = ((y + 1) * w) + x;
  if (y + 1 >= h) {lS = -1;}
  int lW = (y * w) + (x - 1);
  if (x - 1 < 0) {lW = -1;}

  int size = w * h;

  if (d[loc] == loc + 2) {
    rLD[loc] = loc;
  } else if (lN != -1 && d[lN] == lN + 2) {
    rLD[loc] = lN;
  } else if (lE != -1 && d[lE] == lE + 2) {
    rLD[loc] = lE;
  } else if (lS != -1 && d[lS] == lS + 2) {
    rLD[loc] = lS;
  } else if (lW != -1 && d[lW] == lW + 2) {
    rLD[loc] = lW;
  } else {
    rLD[loc] = -1;
  }


  // Analysis phase

  // every pixel is supposed to find a root-pixel, which is a pixel whose
  // label is the same as its init value. The following is a bad
  // implementation where instead the root-pixel value is spread from the
  // root to the other pixels in the component

  bool loop_check = 1;

  if (lN != -1 && lE != -1 && lS != -1 && lW != -1 &&
         (d[lN] == 0) && 
         (d[lE] == 0) && 
         (d[lS] == 0) &&
         (d[lW] == 0)) {
        loop_check = 0;
    }

  if (d[loc] > 0 && rLD[loc] == -1 && loop_check) {
    int i = 0;
    while (true) {
      i++;
      if (lN >= 0 && lN < size && rLD[lN] != -1 && rLD[lN] != -2 && d[lN] > 0) {
        //atomic_xchg(&rLD[loc], rLD[lN]);
        rLD[loc] = rLD[lN];
        break;
      } else if (lE != -1 && lE < size && rLD[lE] != -1 && rLD[lE] != -2 && 
                    d[lE] > 0) {
        //atomic_xchg(&rLD[loc], rLD[lE]);
        rLD[loc] = rLD[lN];
        break;
      } else if (lS != -1 && lS < size && rLD[lS] != -1 && rLD[lS] != -2 && 
                    d[lS] > 0) {
        //atomic_xchg(&rLD[loc], rLD[lS]);
        rLD[loc] = rLD[lS];
        break;
      } else if (lW >= 0 && lW < size && rLD[lW] != -1 && rLD[lW] != -2 && 
                    d[lW] > 0) {
        //atomic_xchg(&rLD[loc], rLD[lW]);
        rLD[loc] = rLD[lW];
        break;
      }
    }
  }

  // after the root has been found you take on it's value
  if (d[loc] > 0 && rLD[loc] >= 0 && rLD[loc] < size &&
      d[rLD[loc]] > 0) {
    //atomic_xchg(&d[loc], d[rLD[loc]]);
    d[loc] = d[rLD[loc]]; 
  }
}

kernel void gpu_kr_link_phase(global int *d, int w, int h, global int *rLD) {
  int x = get_global_id(0);
  int y = get_global_id(1);

  int loc = (y * w) + x;

  int lN = ((y - 1) * w) + x;
  if (y - 1 < 0) {lN = -1;}
  int lE = (y * w) + (x + 1);
  if (x + 1 >= w) {lE = -1;}
  int lS = ((y + 1) * w) + x;
  if (y + 1 >= h) {lS = -1;}
  int lW = (y * w) + (x - 1);
  if (x - 1 < 0) {lW = -1;}

  int size = w * h;
  // Link phase
  // checking the left and right pixels, comparing root-pixel value.
  // if any of the others have a lower value, update your own root
  // with that value


  if (d[loc] > 0 && rLD[loc] != -1 && rLD[loc] >= 0 && rLD[loc] < size &&
      d[rLD[loc]] > 0) {

    // the article points to this section proclaiming that it has a
    // datarace, however it can be solved using the cuda function
    // atomicMin
    
    if (lW >= 0 && lW < size && d[lW] > 0 && d[lW] < d[loc] && rLD[lW] != -1) {
        atomic_xchg(&rLD[loc], rLD[lW]);
    }
    if (lE != -1 && lE < size && d[lE] > 0 && d[lE] < d[loc] && rLD[lE] != -1) {
        atomic_xchg(&rLD[loc], rLD[lE]);
    }
  }
}

kernel void gpu_kr_final_phases(global int *d, int w, int h, global char *iter,
                                global int *rLD) {
  int x = get_global_id(0);
  int y = get_global_id(1);

  int loc = (y * w) + x;

  int lN = ((y - 1) * w) + x;
  if (y - 1 < 0) {lN = -1;}
  int lE = (y * w) + (x + 1);
  if (x + 1 >= w) {lE = -1;}
  int lS = ((y + 1) * w) + x;
  if (y + 1 >= h) {lS = -1;}
  int lW = (y * w) + (x - 1);
  if (x - 1 < 0) {lW = -1;}

  int size = w * h;

  // Label phase
  // You take on the (maybe) updated root-value

  if (d[loc] > 0 && rLD[loc] >= 0 && rLD[loc] < size &&
      d[rLD[loc]] > 0 && rLD[rLD[loc]] == rLD[loc]) {
    //atomic_xchg(&d[loc], d[rLD[loc]]);
    d[loc] = d[rLD[loc]];
  }

  // Rescan phase
  // check if the process is complete, otherwise itterate

  if (d[loc] > 0) {
    if ((lN >= 0 && d[lN] > 0 && d[lN] != d[loc]) ||
        (lE != -1 && lE < size && d[lE] > 0 && d[lE] != d[loc]) ||
        (lE != -1 && lS < size && d[lS] > 0 && d[lS] != d[loc]) ||
        (lW >= 0 && d[lW] > 0 && d[lW] != d[loc])) {
      *iter = 1;
    }
  }

  rLD[loc] = -2;
}


